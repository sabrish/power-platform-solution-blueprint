import type { BlueprintResult } from '../core';

/**
 * Common system entities that clutter diagrams
 */
const SYSTEM_ENTITIES = [
  'systemuser',
  'team',
  'businessunit',
  'organization',
  'transactioncurrency',
  'owner',
];

/**
 * Check if an entity is a system entity that should be excluded from dbdiagram.io
 */
function isSystemEntity(entityLogicalName: string): boolean {
  const lowerName = entityLogicalName.toLowerCase();
  return SYSTEM_ENTITIES.includes(lowerName);
}

/**
 * Check if a relationship is a system relationship that should be filtered
 */
function isSystemRelationship(
  schemaName: string,
  referencingAttribute?: string,
  referencedEntity?: string,
  referencingEntity?: string
): boolean {
  const lowerSchemaName = schemaName.toLowerCase();
  const lowerAttribute = referencingAttribute?.toLowerCase() || '';
  const lowerReferencedEntity = referencedEntity?.toLowerCase() || '';
  const lowerReferencingEntity = referencingEntity?.toLowerCase() || '';

  // Filter if relationship involves a system entity
  if (SYSTEM_ENTITIES.some(entity =>
    lowerReferencedEntity === entity || lowerReferencingEntity === entity
  )) {
    return true;
  }

  const systemPatterns = [
    'createdby',
    'modifiedby',
    'createdonbehalfby',
    'modifiedonbehalfby',
    'ownerid',
    'owninguser',
    'owningteam',
    'owningbusinessunit',
    'transactioncurrencyid',
    'transactioncurrency',
    '_transactioncurrency',
  ];

  return systemPatterns.some(pattern =>
    lowerSchemaName.includes(pattern) || lowerAttribute.includes(pattern)
  );
}

/**
 * Generates dbdiagram.io compatible code from a BlueprintResult
 * Format: https://dbdiagram.io/d
 */
export function generateDbDiagramCode(result: BlueprintResult): string {
  const lines: string[] = [];

  // Add header comment
  lines.push('// Generated by Power Platform Solution Blueprint (PPSB)');
  lines.push(`// ${result.metadata.generatedAt}`);
  lines.push('// Paste this code at https://dbdiagram.io/d to visualize');
  lines.push('');

  // Track processed relationships to avoid duplicates
  const processedRelationships = new Set<string>();

  // Build set of entities actually in the export (excluding system entities)
  const exportedEntities = new Set<string>();
  for (const entityBlueprint of result.entities) {
    const tableName = entityBlueprint.entity.LogicalName.toLowerCase();
    if (!isSystemEntity(tableName)) {
      exportedEntities.add(tableName);
    }
  }

  // Process each entity (skip system entities)
  for (const entityBlueprint of result.entities) {
    const entity = entityBlueprint.entity;
    const tableName = entity.LogicalName;

    // Skip system entities (systemuser, team, businessunit, etc.)
    if (isSystemEntity(tableName)) {
      continue;
    }

    lines.push(`Table ${tableName} {`);

    // Add table note with display name (escape single quotes)
    const displayName = entity.DisplayName?.UserLocalizedLabel?.Label || tableName;
    lines.push(`  Note: '${displayName.replace(/'/g, "\\'")}'`);
    lines.push('');

    // Add attributes
    const attributes = entity.Attributes || [];
    for (const attr of attributes) {
      const columnName = attr.LogicalName;
      const dataType = mapAttributeTypeToDbType(attr.AttributeType);
      const constraints: string[] = [];

      // Primary key
      if (attr.IsPrimaryId) {
        constraints.push('pk');
      }

      // Required field
      if (attr.RequiredLevel?.Value === 'ApplicationRequired' || attr.RequiredLevel?.Value === 'SystemRequired') {
        constraints.push('not null');
      }

      // Add note with display name
      const attrDisplayName = attr.DisplayName?.UserLocalizedLabel?.Label;
      if (attrDisplayName && attrDisplayName !== columnName) {
        constraints.push(`note: '${attrDisplayName.replace(/'/g, "\\'")}'`);
      }

      const constraintStr = constraints.length > 0 ? ` [${constraints.join(', ')}]` : '';
      lines.push(`  ${columnName} ${dataType}${constraintStr}`);
    }

    lines.push('}');
    lines.push('');
  }

  // Process relationships
  lines.push('// Relationships');
  lines.push('');

  for (const entityBlueprint of result.entities) {
    const entity = entityBlueprint.entity;

    // Many-to-One relationships (this entity references another)
    const manyToOneRels = entity.ManyToOneRelationships || [];
    for (const rel of manyToOneRels) {
      // Skip system relationships
      if (isSystemRelationship(
        rel.SchemaName,
        rel.ReferencingAttribute,
        rel.ReferencedEntity,
        rel.ReferencingEntity
      )) {
        continue;
      }

      // Skip if either entity is not in the export
      if (!exportedEntities.has(rel.ReferencingEntity.toLowerCase()) ||
          !exportedEntities.has(rel.ReferencedEntity.toLowerCase())) {
        continue;
      }

      const relKey = `${rel.ReferencingEntity}.${rel.ReferencingAttribute}->${rel.ReferencedEntity}.${rel.ReferencedAttribute}`;
      if (!processedRelationships.has(relKey)) {
        processedRelationships.add(relKey);
        // Many-to-one: ReferencingEntity.ReferencingAttribute > ReferencedEntity.ReferencedAttribute
        lines.push(`Ref: ${rel.ReferencingEntity}.${rel.ReferencingAttribute} > ${rel.ReferencedEntity}.${rel.ReferencedAttribute}`);
      }
    }

    // Many-to-Many relationships - documented as comments since they exist via intersection tables
    const manyToManyRels = entity.ManyToManyRelationships || [];
    for (const rel of manyToManyRels) {
      // Skip system relationships
      if (isSystemRelationship(
        rel.SchemaName,
        undefined,
        rel.Entity1LogicalName,
        rel.Entity2LogicalName
      )) {
        continue;
      }

      // Skip if either entity is not in the export
      if (!exportedEntities.has(rel.Entity1LogicalName.toLowerCase()) ||
          !exportedEntities.has(rel.Entity2LogicalName.toLowerCase())) {
        continue;
      }

      // Create a relationship key to avoid duplicates (both entities will have this relationship)
      const entities = [rel.Entity1LogicalName, rel.Entity2LogicalName].sort();
      const relKey = `${entities[0]}<>${entities[1]}:${rel.IntersectEntityName}`;

      if (!processedRelationships.has(relKey)) {
        processedRelationships.add(relKey);
        // Document M:N as comment - actual relationship exists via intersection table
        lines.push(`// M:N: ${rel.Entity1LogicalName} <> ${rel.Entity2LogicalName} (via ${rel.IntersectEntityName})`);
      }
    }
  }

  return lines.join('\n');
}

/**
 * Maps Dataverse attribute types to database column types for dbdiagram.io
 */
function mapAttributeTypeToDbType(attributeType: string): string {
  const typeMap: Record<string, string> = {
    'String': 'nvarchar',
    'Memo': 'nvarchar(max)',
    'Integer': 'int',
    'BigInt': 'bigint',
    'Decimal': 'decimal',
    'Double': 'float',
    'Money': 'money',
    'Boolean': 'bit',
    'DateTime': 'datetime',
    'Lookup': 'uniqueidentifier',
    'Customer': 'uniqueidentifier',
    'Owner': 'uniqueidentifier',
    'Uniqueidentifier': 'uniqueidentifier',
    'Picklist': 'int',
    'State': 'int',
    'Status': 'int',
    'Virtual': 'nvarchar',
    'EntityName': 'nvarchar',
    'ManagedProperty': 'bit',
  };

  return typeMap[attributeType] || 'nvarchar';
}
