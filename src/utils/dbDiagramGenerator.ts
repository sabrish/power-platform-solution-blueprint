import type { BlueprintResult } from '../core';
import { isSystemEntity, isSystemRelationship } from './systemFilters.js';

/**
 * Generates dbdiagram.io compatible code from a BlueprintResult
 * Format: https://dbdiagram.io/d
 */
export function generateDbDiagramCode(result: BlueprintResult): string {
  const lines: string[] = [];

  // Add header comment
  lines.push('// Generated by Power Platform Solution Blueprint (PPSB)');
  lines.push(`// ${result.metadata.generatedAt}`);
  lines.push('// Paste this code at https://dbdiagram.io/d to visualize');
  lines.push('');

  // Track processed relationships to avoid duplicates
  const processedRelationships = new Set<string>();

  // Build set of entities actually in the export (excluding system entities)
  const exportedEntities = new Set<string>();
  // Build map of entity -> set of attribute names (to validate relationships)
  const entityAttributes = new Map<string, Set<string>>();

  for (const entityBlueprint of result.entities) {
    const tableName = entityBlueprint.entity.LogicalName.toLowerCase();
    if (!isSystemEntity(tableName)) {
      exportedEntities.add(tableName);

      // Build attribute set for this entity
      const attributes = new Set<string>();
      for (const attr of entityBlueprint.entity.Attributes || []) {
        attributes.add(attr.LogicalName.toLowerCase());
      }
      entityAttributes.set(tableName, attributes);
    }
  }

  // Process each entity (skip system entities)
  for (const entityBlueprint of result.entities) {
    const entity = entityBlueprint.entity;
    const tableName = entity.LogicalName;

    // Skip system entities (systemuser, team, businessunit, etc.)
    if (isSystemEntity(tableName)) {
      continue;
    }

    lines.push(`Table ${tableName} {`);

    // Add table note with display name (escape single quotes)
    const displayName = entity.DisplayName?.UserLocalizedLabel?.Label || tableName;
    lines.push(`  Note: '${displayName.replace(/'/g, "\\'")}'`);
    lines.push('');

    // Add attributes
    const attributes = entity.Attributes || [];
    for (const attr of attributes) {
      const columnName = attr.LogicalName;
      const dataType = mapAttributeTypeToDbType(attr.AttributeType);
      const constraints: string[] = [];

      // Primary key
      if (attr.IsPrimaryId) {
        constraints.push('pk');
      }

      // Required field
      if (attr.RequiredLevel?.Value === 'ApplicationRequired' || attr.RequiredLevel?.Value === 'SystemRequired') {
        constraints.push('not null');
      }

      // Add note with display name
      const attrDisplayName = attr.DisplayName?.UserLocalizedLabel?.Label;
      if (attrDisplayName && attrDisplayName !== columnName) {
        constraints.push(`note: '${attrDisplayName.replace(/'/g, "\\'")}'`);
      }

      const constraintStr = constraints.length > 0 ? ` [${constraints.join(', ')}]` : '';
      lines.push(`  ${columnName} ${dataType}${constraintStr}`);
    }

    lines.push('}');
    lines.push('');
  }

  // Process relationships
  lines.push('// Relationships');
  lines.push('');

  for (const entityBlueprint of result.entities) {
    const entity = entityBlueprint.entity;

    // Many-to-One relationships (this entity references another)
    const manyToOneRels = entity.ManyToOneRelationships || [];
    for (const rel of manyToOneRels) {
      // Skip system relationships
      if (isSystemRelationship(
        rel.SchemaName,
        rel.ReferencingAttribute,
        rel.ReferencedEntity,
        rel.ReferencingEntity
      )) {
        continue;
      }

      // Skip if either entity is not in the export
      if (!exportedEntities.has(rel.ReferencingEntity.toLowerCase()) ||
          !exportedEntities.has(rel.ReferencedEntity.toLowerCase())) {
        continue;
      }

      // Skip if either attribute doesn't exist in the entity definition
      const referencingAttrs = entityAttributes.get(rel.ReferencingEntity.toLowerCase());
      const referencedAttrs = entityAttributes.get(rel.ReferencedEntity.toLowerCase());
      if (!referencingAttrs?.has(rel.ReferencingAttribute.toLowerCase()) ||
          !referencedAttrs?.has(rel.ReferencedAttribute.toLowerCase())) {
        continue;
      }

      const relKey = `${rel.ReferencingEntity}.${rel.ReferencingAttribute}->${rel.ReferencedEntity}.${rel.ReferencedAttribute}`;
      if (!processedRelationships.has(relKey)) {
        processedRelationships.add(relKey);
        // Many-to-one: ReferencingEntity.ReferencingAttribute > ReferencedEntity.ReferencedAttribute
        lines.push(`Ref: ${rel.ReferencingEntity}.${rel.ReferencingAttribute} > ${rel.ReferencedEntity}.${rel.ReferencedAttribute}`);
      }
    }

    // Many-to-Many relationships - documented as comments since they exist via intersection tables
    const manyToManyRels = entity.ManyToManyRelationships || [];
    for (const rel of manyToManyRels) {
      // Skip system relationships
      if (isSystemRelationship(
        rel.SchemaName,
        undefined,
        rel.Entity1LogicalName,
        rel.Entity2LogicalName
      )) {
        continue;
      }

      // Skip if either entity is not in the export
      if (!exportedEntities.has(rel.Entity1LogicalName.toLowerCase()) ||
          !exportedEntities.has(rel.Entity2LogicalName.toLowerCase())) {
        continue;
      }

      // Create a relationship key to avoid duplicates (both entities will have this relationship)
      const entities = [rel.Entity1LogicalName, rel.Entity2LogicalName].sort();
      const relKey = `${entities[0]}<>${entities[1]}:${rel.IntersectEntityName}`;

      if (!processedRelationships.has(relKey)) {
        processedRelationships.add(relKey);
        // Document M:N as comment - actual relationship exists via intersection table
        lines.push(`// M:N: ${rel.Entity1LogicalName} <> ${rel.Entity2LogicalName} (via ${rel.IntersectEntityName})`);
      }
    }
  }

  return lines.join('\n');
}

/**
 * Maps Dataverse attribute types to database column types for dbdiagram.io
 */
function mapAttributeTypeToDbType(attributeType: string): string {
  const typeMap: Record<string, string> = {
    'String': 'nvarchar',
    'Memo': 'nvarchar(max)',
    'Integer': 'int',
    'BigInt': 'bigint',
    'Decimal': 'decimal',
    'Double': 'float',
    'Money': 'money',
    'Boolean': 'bit',
    'DateTime': 'datetime',
    'Lookup': 'uniqueidentifier',
    'Customer': 'uniqueidentifier',
    'Owner': 'uniqueidentifier',
    'Uniqueidentifier': 'uniqueidentifier',
    'Picklist': 'int',
    'State': 'int',
    'Status': 'int',
    'Virtual': 'nvarchar',
    'EntityName': 'nvarchar',
    'ManagedProperty': 'bit',
  };

  return typeMap[attributeType] || 'nvarchar';
}
